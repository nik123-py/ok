"""
Vulnerability scanning tools module.
Scans for common vulnerabilities in discovered services and ports.
Integrates ML-based vulnerability detection using pre-trained model.
"""

from typing import Dict, List, Optional
from dataclasses import dataclass
import random
import os

# Try to import ML model wrapper, fallback to None if not available
try:
    from ml_vulnerability_model import VulnerabilityModelWrapper
    ML_MODEL_AVAILABLE = True
except ImportError:
    ML_MODEL_AVAILABLE = False
    VulnerabilityModelWrapper = None


@dataclass
class Vulnerability:
    """Represents a discovered vulnerability"""
    cve_id: Optional[str]
    name: str
    severity: str  # critical, high, medium, low
    description: str
    affected_service: str
    affected_port: Optional[int] = None
    exploit_available: bool = False
    remediation: str = ""


class VulnerabilityScanner:
    """
    Vulnerability scanner for discovered services.
    Simulates scanning for common vulnerabilities.
    """

    # Common vulnerabilities by service
    SERVICE_VULNERABILITIES = {
        "HTTP": [
            {
                "name": "SQL Injection",
                "severity": "high",
                "cve": "CVE-2023-XXXXX",
                "description": "SQL injection vulnerability in login endpoint",
                "exploit_available": True
            },
            {
                "name": "Cross-Site Scripting (XSS)",
                "severity": "medium",
                "cve": "CVE-2023-YYYYY",
                "description": "Reflected XSS in search parameter",
                "exploit_available": True
            },
            {
                "name": "Path Traversal",
                "severity": "high",
                "cve": "CVE-2023-ZZZZZ",
                "description": "Directory traversal in file download endpoint",
                "exploit_available": True
            }
        ],
        "HTTPS": [
            {
                "name": "SSL/TLS Weak Cipher",
                "severity": "medium",
                "cve": "CVE-2023-AAAAA",
                "description": "Weak SSL/TLS cipher suite enabled",
                "exploit_available": False
            },
            {
                "name": "Certificate Validation Bypass",
                "severity": "high",
                "cve": "CVE-2023-BBBBB",
                "description": "Certificate pinning can be bypassed",
                "exploit_available": True
            }
        ],
        "SSH": [
            {
                "name": "Weak SSH Key",
                "severity": "medium",
                "cve": None,
                "description": "Weak or default SSH keys detected",
                "exploit_available": True
            },
            {
                "name": "SSH Version Disclosure",
                "severity": "low",
                "cve": None,
                "description": "SSH version information disclosure",
                "exploit_available": False
            }
        ],
        "FTP": [
            {
                "name": "Anonymous FTP Access",
                "severity": "medium",
                "cve": None,
                "description": "FTP allows anonymous login",
                "exploit_available": True
            },
            {
                "name": "FTP Bounce Attack",
                "severity": "low",
                "cve": "CVE-2023-CCCCC",
                "description": "FTP server vulnerable to bounce attacks",
                "exploit_available": False
            }
        ],
        "MySQL": [
            {
                "name": "SQL Injection",
                "severity": "critical",
                "cve": "CVE-2023-DDDDD",
                "description": "SQL injection in authentication",
                "exploit_available": True
            },
            {
                "name": "Weak Password",
                "severity": "high",
                "cve": None,
                "description": "Default or weak database password",
                "exploit_available": True
            }
        ],
        "PostgreSQL": [
            {
                "name": "Remote Code Execution",
                "severity": "critical",
                "cve": "CVE-2023-EEEEE",
                "description": "RCE vulnerability in PostgreSQL",
                "exploit_available": True
            }
        ],
        "Redis": [
            {
                "name": "Unauthenticated Access",
                "severity": "high",
                "cve": None,
                "description": "Redis exposed without authentication",
                "exploit_available": True
            }
        ],
        "Elasticsearch": [
            {
                "name": "Remote Code Execution",
                "severity": "critical",
                "cve": "CVE-2023-FFFFF",
                "description": "RCE via Elasticsearch query",
                "exploit_available": True
            }
        ]
    }

    # Remediation suggestions
    REMEDIATIONS = {
        "SQL Injection": "Use parameterized queries and input validation",
        "Cross-Site Scripting (XSS)": "Implement output encoding and CSP headers",
        "Path Traversal": "Validate and sanitize file paths",
        "SSL/TLS Weak Cipher": "Disable weak cipher suites",
        "Certificate Validation Bypass": "Implement proper certificate pinning",
        "Weak SSH Key": "Use strong SSH keys and disable password authentication",
        "Anonymous FTP Access": "Disable anonymous FTP access",
        "Weak Password": "Enforce strong password policies",
        "Remote Code Execution": "Update to latest version and restrict access",
        "Unauthenticated Access": "Enable authentication and restrict network access"
    }

    def __init__(self, use_ml_model: bool = True, model_path: Optional[str] = None):
        """
        Initialize vulnerability scanner.
        
        Args:
            use_ml_model: Whether to use ML model for detection (default: True)
            model_path: Optional path to model.pt file
        """
        self.scan_results = []
        self.use_ml_model = use_ml_model and ML_MODEL_AVAILABLE
        self.ml_model = None
        
        if self.use_ml_model:
            try:
                self.ml_model = VulnerabilityModelWrapper(model_path=model_path)
                print("ML vulnerability detection model initialized")
            except Exception as e:
                print(f"Warning: Could not initialize ML model: {e}")
                print("Falling back to rule-based detection")
                self.use_ml_model = False

    def scan_target(self, target: str, open_ports: List[Dict], services: Optional[List[Dict]] = None) -> List[Dict]:
        """
        Scan target for vulnerabilities based on open ports.
        Uses ML model if available, otherwise falls back to rule-based detection.
        
        Args:
            target: Target hostname or IP
            open_ports: List of open ports from port scan
            services: Optional list of service information
            
        Returns:
            List of discovered vulnerabilities
        """
        vulnerabilities = []
        
        # Try ML model first if enabled
        if self.use_ml_model and self.ml_model:
            try:
                ml_vulnerabilities = self.ml_model.predict(target, open_ports, services)
                if ml_vulnerabilities:
                    print(f"ML model detected {len(ml_vulnerabilities)} vulnerabilities")
                    vulnerabilities.extend(ml_vulnerabilities)
                    # Return ML results if we got any, otherwise fall through to rule-based
                    if vulnerabilities:
                        return vulnerabilities
            except Exception as e:
                print(f"ML model prediction failed: {e}")
                print("Falling back to rule-based detection")
        
        # Fallback to rule-based detection (original logic)

        for port_info in open_ports:
            service = port_info.get("service", "")
            port = port_info.get("port")
            
            # Get vulnerabilities for this service
            service_vulns = self.SERVICE_VULNERABILITIES.get(service, [])
            
            # Simulate finding some vulnerabilities (not all)
            # Higher severity vulnerabilities more likely to be found
            for vuln_template in service_vulns:
                # Probability of finding vulnerability
                severity_weights = {
                    "critical": 0.9,
                    "high": 0.7,
                    "medium": 0.5,
                    "low": 0.3
                }
                
                probability = severity_weights.get(vuln_template["severity"], 0.5)
                
                # Deterministic based on target+service
                target_hash = hash(f"{target}:{service}:{vuln_template['name']}") % 100
                found = target_hash < (probability * 100)

                if found:
                    vulnerability = Vulnerability(
                        cve_id=vuln_template.get("cve"),
                        name=vuln_template["name"],
                        severity=vuln_template["severity"],
                        description=vuln_template["description"],
                        affected_service=service,
                        affected_port=port,
                        exploit_available=vuln_template.get("exploit_available", False),
                        remediation=self.REMEDIATIONS.get(
                            vuln_template["name"],
                            "Update software and apply security patches"
                        )
                    )
                    
                    vulnerabilities.append({
                        "cve_id": vulnerability.cve_id,
                        "name": vulnerability.name,
                        "severity": vulnerability.severity,
                        "description": vulnerability.description,
                        "affected_service": vulnerability.affected_service,
                        "affected_port": vulnerability.affected_port,
                        "exploit_available": vulnerability.exploit_available,
                        "remediation": vulnerability.remediation
                    })

        return vulnerabilities

    def scan_service(self, service: str, port: int, version: Optional[str] = None) -> List[Dict]:
        """
        Scan specific service for vulnerabilities.
        
        Args:
            service: Service name
            port: Port number
            version: Optional service version
            
        Returns:
            List of vulnerabilities
        """
        vulnerabilities = []

        service_vulns = self.SERVICE_VULNERABILITIES.get(service, [])
        
        for vuln_template in service_vulns:
            # Check version-specific vulnerabilities if version provided
            if version:
                # In real scenario, would check CVE database for version
                pass

            vulnerability = {
                "cve_id": vuln_template.get("cve"),
                "name": vuln_template["name"],
                "severity": vuln_template["severity"],
                "description": vuln_template["description"],
                "affected_service": service,
                "affected_port": port,
                "exploit_available": vuln_template.get("exploit_available", False),
                "remediation": self.REMEDIATIONS.get(
                    vuln_template["name"],
                    "Update software and apply security patches"
                )
            }
            
            vulnerabilities.append(vulnerability)

        return vulnerabilities

    def get_vulnerability_details(self, cve_id: str) -> Optional[Dict]:
        """
        Get detailed information about a specific CVE.
        
        Args:
            cve_id: CVE identifier
            
        Returns:
            Detailed vulnerability information
        """
        # In real scenario, would query CVE database
        # For MVP, return mock data
        if not cve_id:
            return None

        return {
            "cve_id": cve_id,
            "published": "2023-01-15",
            "modified": "2023-02-20",
            "description": "Detailed vulnerability description",
            "severity": "high",
            "cvss_score": 7.5,
            "references": [
                f"https://cve.mitre.org/cgi-bin/cvename.cgi?name={cve_id}",
                "https://example.com/advisory"
            ],
            "affected_versions": "All versions < 2.0.0",
            "fixed_versions": "2.0.0+"
        }

    def scan_web_application(self, url: str) -> List[Dict]:
        """
        Perform web application vulnerability scan.
        
        Args:
            url: Target URL
            
        Returns:
            List of web vulnerabilities
        """
        # Common web vulnerabilities
        web_vulns = [
            {
                "name": "SQL Injection",
                "severity": "high",
                "endpoint": "/api/login",
                "parameter": "username",
                "description": "SQL injection in login endpoint"
            },
            {
                "name": "Cross-Site Scripting (XSS)",
                "severity": "medium",
                "endpoint": "/search",
                "parameter": "q",
                "description": "Reflected XSS in search parameter"
            },
            {
                "name": "Insecure Direct Object Reference",
                "severity": "medium",
                "endpoint": "/api/users/{id}",
                "parameter": "id",
                "description": "IDOR vulnerability allows access to other users' data"
            }
        ]

        # Simulate finding some vulnerabilities
        discovered = []
        for vuln in web_vulns:
            url_hash = hash(f"{url}:{vuln['name']}") % 100
            if url_hash < 60:  # 60% chance
                discovered.append({
                    **vuln,
                    "cve_id": None,
                    "exploit_available": True,
                    "remediation": self.REMEDIATIONS.get(vuln["name"], "Implement proper access controls")
                })

        return discovered

